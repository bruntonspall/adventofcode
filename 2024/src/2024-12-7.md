---
title: Day 7 - It's turtles all the way down
tags: adventofcode aoc2024
layout: post
---

# Day 7 - Part 1

Oh this is interesting, we have operands and operators, we must work out which operators might work

There's going to be a lot of combinations here, but given only 2 operators, it's roughly n-squared for the number of  operands, so it's not the worst performance. 

I think a brute force search here is probably easiest.

We also can easily fold the answers as we calculate from left to rihgt, rather than any form of precedence rules.

So we need to read in something like 123: 1 23 and turn that into a total, and a vector of arguments.

We can then conduct a solve by trying combinations of operands for a given set of arguments...

That's a lot easier to write than code... 

If we have operands MUL, and ADD, we need to work out how to handle `MUL(ADD(1,2),3)`.
We could take something like `[1 2 3]`, and emit two options, `[3 3]` and `[2 3]`, which is defined as `[op(h1, h2), t]`
Or we could define some intermediate standard, like `[1, MUL 2, ADD 3]`, where each operand takes the previous result 
and the next value.

I suspect for part 2, we might want to do the latter, but for now, I think we can try the first option.
so for `[2 4 8]`, we have `ADD(2,4) -> [6 8]`, and `MUL(2,4) -> [8 8]`, and then `ADD(6,8) -> [8]` and `MUL(8,8) -> [64]`
We can end whenever we have a single answer, and of course, we then want to know how many of the answers were valid.

I strongly suspect that part 2 will require us to handle precedence, but we'll handle that when we get there.

## Playing with AI

Ok, so while out on a walk, I pulled out my phone and asked Claude.ai for some tips on how to solve this, and 
it suggested a recursive algorithm with backtracking, which is of course, exactly how to easily solve this.  I don't know why I didn't think of it before.

A recursive algorithm with backtracking is a great way to solve a problem involving combinations.  The classic example of a recursive algorithm is working out the given sum of a fibonacci sequence.  A given fibonacci number starts with the sequence 1, 1 and then is otherwise determined to be the sum of the previous 2 numbers, so 1+1 = 2, 1+2 = 3, 2+3 = 5 and so on.

You can work this out iteratively, but it's often much clearer and easier to work this out recursively, by defining a function that works out for fib(n) what fib(n-1)+fib(n-2) is.  Of course, in order to work out what fib(n-1) is, it will also have to work out what fib(n-2) is.  For simple cases, like the fibonacci sequence, this may not be an issue (and likely isn't in our case), but for anything complex or with really long inputs, we may want to cache results we've already worked out, through something called memoisation.  But I think we'll come back to that on another day.

Let's start with the recursive function, and then come to backtracking later.

```rust
pub fn total(running_total:u32, args: &Vec<u32>, index: usize) -> u32 {
    // Our base case, make sure it returns when we run out of numbers
    if index == args.len() {
        return running_total;
    }
    // Handle addition, which is running_total + args[index] and repeat for next index
    total(running_total+args[index], args, index+1)
}
```

This function just does addition, and it works out that the sum of a given series is the running total  of the rest of the series plus the current number.

We can also work out multiplication the same way, but this doesn't help us with identifying whether multiplication or addition is the right answer for a given total... for that we're going to need a goal and that's where backtracking comes in.

In the current case, we simply end when we've got to the end of the arguments, but in our new backtracking model, we're also going to take a target number we want to reach.  

Instead of simply returning the sum when we run out of numbers, we're now going to compare whether we have hit the target or not.

```rust
if running_total == target
  { 1 }
else
  { 0 }
```

See, we only want to count the number of successful ways that the operations could be applied, we don't need to know how they worked or not.

We'll then say that the total ways to solve `[1,2,3]` for target 6, with total 0 is the sum of trying all the ways to solve `[2,3]` for target 6 with total 1, which is solving `[3]` for target 6 with total `1+2` and for solving `[3]` for target 6 with total `1*2`, which is the same as... and so it goes.  At the end, those that end up with 6 return 1, those that don't end up with 0, and we wind all the way back with a total of 2.

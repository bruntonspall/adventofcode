---
title: Day 14 - Not really a grid
tags: 
- adventofcode 
- aoc2024
layout: post
date: 2024-12-23
---
# Day 14 Part 1 - That looks a lot like a grid

Ok, I've reached the part of Advent of Code where I'm picking and choosing my puzzles based on whether I can grok the problem straight away or not, which normally bites me for part 2, but lets try this anyway.

This one has robots that move in a striaght line according to a start point and a velocity.  We can draw a grid of the robots and see where they all move to from turn to turn and the examples do indeed have a nice grid laid out, like this:

```
1.12.......
...........
...........
......11.11
1.1........
.........1.
.......1...
```

However, looking at the problem description, with robots moving in a straight line, and wrapping the world as if it's a donut (so from top to bottom and right to left, actually a toroidal plane), this is actually a very simple maths transformation.

We want to do that for hundreds of robots and varying velocities and find out which quadrant they all end up in.

In the first example we have a robot who starts a `(2,4)` and has a velocity of `(2,-3)`. (note that in a moment of mass confusion, for the examples, they have y going down, so 0,0 is the top left corner)

He starts looking like this:
```
...........
...........
...........
...........
..1........
...........
...........
```

and after one move is here:

```
...........
....1......
...........
...........
...........
...........
...........
```

But if we look at that as coordinates, he starts at `(2,4)` and after 1 move is at `(4,1)` and after a second move is at `(6,5)`.  What we're actually saying is that the end coordinate of any given robot is simply `start + velocity * magnitude` with the coordinates then produced modulo the height and width of the toroid.

So I'm going to create a new Toroidal Coordinate that takes not just a coordinate, but references a limit, and when added or multiplied, will use the modulo.  We can then just add the robots velocities times the number of seconds to the original coordinates and count the robots in the quadrants.

Here's our coordinate and our vector class (you can see my writeup for [Day 4](/2024/2024-12-04) to see why it's a vector).

```rust
#[derive(Debug, Copy, Clone, PartialEq, Hash, Eq)]
pub struct ToroidalCoordinate {
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
}

#[derive(Debug, Copy, Clone, PartialEq, Hash, Eq)]
pub struct Vector {
    pub dx: i32,
    pub dy: i32,
}
```

Everything else is standard, but let's look at the Add function

```rust
/* We want to add a Vector to Coordinate to result in a new Coordinate, which is std::ops:Add to enable us to use the + symbol in the compiler */
impl std::ops::Add<Vector> for ToroidalCoordinate {
    type Output = Self;
    fn add(self, other: Vector) -> Self {
        Self {
            x: (self.x + other.dx).rem_euclid(self.width),
            y: (self.y + other.dy).rem_euclid(self.height),
            width: self.width,
            height: self.height,
        }
    }
}
```

The rem_euclid is a bit funky, and that's because like many languages, rust has a remainder operator, rather than a modulo operator.  The remainder operator works out what the remainder is if you divide a by b, so if you do 7's into 4, you have 1 4, and a remainder of 3.  This acts like working out the modulo for positive numbers, but negative numbers are slightly more complicated.  The way one works out the modulo of a negative number is supposed to work more like clock arithmatic, so for example, -1's into 4.  How many 4's go into -1, none, and what's left is a -1.  But in modulus arithmatic, we actually expect the answer to be 3, because any number lower than 0 should wrap round to the modulo and keep going.  This is true if there are bigger numbers, so 4's into -5, is 1 4, and then remainder of -1.  So our remainder will give the wrong number unless we use a specific function for euclidian remainders (which was a new term to me, but is another term for modulo operations apparently).

## Moving a paranoid android

Anyway, this works in our tests, so let's create some robots, parse the input lines, and try moving them in the test environment.


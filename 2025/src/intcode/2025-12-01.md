---
title: Day 1 - Secret Entrance
tags: 
- adventofcode 
- aoc2025
layout: post
date: 2025-12-01
---
# 2025 Day 1

Here we go!  I had to clear down a bunch of left over Intcode Day 5 stuff in order to get ready to do this.

So, a simple looking problem to start day one with.  Rotate a dial left or right through 0-99 using "clock arithmatic", which feels mathmatically simple.

We can just parse the input, probably mapping right to positive numbers and left to negative numbers.  We can add 99 to number, modulo 99 and we should get the right result.  We can use a map to turn from our start number, through each turn, and then filter that stream by the predicate of whether they are 0.

First, to parse the numbers, it's just like normal, split by lines, and then we're going to match against strings and use guard clauses to separate left from right.  This is because Rust is UTF compatible, which makes getting "the first character" from a string non-trivial.  The guard clauses works well to do what we want without lots of weird casting.  If it starts R, parse the number, if it starts L, return the negative of the number.

This gives us:

```rust
_input
    .lines()
    .map(|line| line.trim())
    .map(|s| match s {
        _ if s.starts_with('R') => s[1..].parse::<i32>().expect("Failed to parse integer"),
        _ if s.starts_with('L') => -s[1..].parse::<i32>().expect("Failed to parse integer"),
        _ => panic!("Invalid direction"),
    })
    .collect()
```

Next we want to sort the rotation in a simple function that takes current position of the dial, and applies the next turn.  

```rust
fn rotate_dial(start: i32, turn: i32) -> i32 {
    (start + turn + 100) % 100
}
```

Now, I more or less know that I can just use fold on this to start with 50, and that will give us our end position.  But we care what positions we pass through, which is a slightly awkward mapping.  Instead I decided to just do a for loop.  I think this could be done better with a fold or reduce somehow, but my brain won't tell me how, so we end up with this.

```rust
fn execute_instructions(start: i32, instructions: &Vec<i32>) -> Vec<i32> {
    let mut dial = start;
    let mut results = Vec::new();
    for &instruction in instructions {
        dial = rotate_dial(dial, instruction);
        results.push(dial);
    }
    results
}
```

That lets me write a simple test to confirm that we get the sequence outlined in my tests

```rust
    fn test_execute_instructions() {
        let input = "L68
L30
R48
L5
R60
L55
L1
L99
R14
L82";
        assert_eq!(
            execute_instructions(50, &parse_input(&input)),
            vec![82, 52, 0, 95, 55, 0, 99, 0, 14, 32]
        );
    }
```

And that means our part 1 can just be a filter over that returned list, counting the occurences of 0.

```rust
    execute_instructions(50, input)
        .into_iter()
        .filter(|&x| x == 0)
        .count()
```

Tests work, lets give this a whirl.
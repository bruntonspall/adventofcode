---
title: Intcode Prep day 5 - Input and Output
tags: 
- adventofcode 
- aoc2025
layout: post
date: 2025-11-23
---
# Intcode Day 5

Today we add input and output to the intcode computer.  We now have Opcode 3 which reads input and puts it into memory, and Opcode 4 which pushes an integer to output.  
Both take addresses that get input or output.

Secondly, we now need to differentiate between position mode and immediate mode.

Thirdly, we need to start to account for the difference in opcode length, as the input and output operations have varying length.

This means that it's probably time to adjust the opcodes to be a structure, an enum and have an implementation.

Currently, we just match on the digit, so 1 mean we execute all the things from add.  But we can move the logic into a set of functions.

The simplest thing is to have an enum of OpCodes, so `OpAdd`, `OpMul` etc, and then within each Op, we define a length.  However the immediate and position modes adds a complication.  Do we repeat the logic in every op for getting param1 in immediate mode, in position mode etc?

I wonder if we can define a GetParam, which can use the opcode to switch for how to get the value?  I'm thinking something like

```rust
fn get_param(opcode: usize, position: usize) -> usize {
    match opcode {
        x if (opcode / 100) % 10 == 1=> self.memory[self.memory[self.pc + position]
        x if (opcode / 1000) % 10  == 1=> self.memory[self.pc + position]
    }
}
```

But that's a bit over complex, why should get parameter care about the opcode?  Far more sensible to pass the mode into the get_param function, and make the opcode understand which mode to use.   This makes get_param similar, but more explicit:
```rust
fn get_param(position: usize, mode: usize) -> usize {
    match mode {
        0 => self.memory[self.memory[self.pc + position]
        1 => self.memory[self.pc + position]
    }
}
```

Let's give this a try, lets sort out the position and immediate mode first, lets start with a simple intcode example that should add two immediate parameters together and loads answer into position 0.

```rust
    let mut cpu = IntCodeCPU::new(vec![1101,1,2,0,99]);
    assert_eq!(cpu.memory[0], 1101);   
    cpu.execute();
    assert_eq!(cpu.pc, 4);
    assert_eq!(cpu.memory[3], 3);   
```

This should fail, as opcode 1101 won't be understood, so we implement our get_param and refit the ad opcode to handle it.  (We need to mod the opcode by 100 to make sure we only get the last 2 digits of course)

```rust
    let opcode = self.memory[self.pc];
    match opcode % 100 {
        1 => {
            let src1 = self.get_parameter(1, (opcode / 100) % 10);
            let src2 = self.get_parameter(2, (opcode / 1000) % 10);
            let dest = self.memory[self.pc+3] as usize;
            self.memory[dest] = src1 + src2;
            self.pc += 4;
        }
        ...
    }
```

That works, lets update the other opcode, test it and then we're good to go


